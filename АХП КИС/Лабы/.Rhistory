Variant<-1
set.seed(Variant)
alpha<-runif(100)[77]
alpha
2/alpha^2
n<-100000
z1<-runif(n,0,2)
z2<-runif(n,0,10)
mean(z1+z2)
n<-100000
z1<-runif(n,0,2)
z2<-runif(n,0,10)
mean(z1+z2)
n<-100000
z1<-runif(n,0,2)
z2<-runif(n,0,10)
s<-sd(z1+z2)
s<-s^2
s
alpha
M_5<-2/alpha
M_5
D_5
D_5<-2/alpha^2
D_5
Variant<-1
set.seed(Variant)
alpha<-runif(100)[77]
alpha
M_5<-2/alpha
M_5
D_5<-2/
Variant<-1
Variant<-1
set.seed(Variant)
alpha<-runif(100)[77]
alpha
M_5<-2/alpha
M_5
D_5<-2/alpha^2
D_5
setwd("C:/Users/user/Desktop/Учёба/8 семестр/АХП КИС/Лабы")
Variant<-1
set.seed(Variant)
k<-sample(c(10:25),1)
t1<-sample(c(14:20),1)
t2<-sample(c(2:5),1)
View(data.frame(k,t1,t2))
event_task_recieve <- vector(mode='double', length=N*k_local)
Variant<-1
set.seed(Variant)
k<-sample(c(10:25),1)
t1<-sample(c(14:20),1)
t2<-sample(c(2:5),1)
View(data.frame(k,t1,t2))
F1 <- function(lk, lt1, lt2, N) {
lambda1 = 1/lt1
lambda2 = 1/lt2
set.seed(Variant)
# вектор событий (времен с начала моделирования) загрузки программ на сервер
getTask <- vector(mode='double', length=N*lk)
getTask[1:lk] <- rexp(lk, lambda1)
for (i in 1:(N-1)) {
getTask[(i*lk+1):(i*lk+lk)] <- getTask[((i-1)*lk+1):(i*lk)] + rexp(lk, lambda1)
}
# print(getTask) => sorted vector(mode='double', length=N*k)
# e.g. 0.5368717806413770.9901529230642491.240166490021951.605907236501722.915671849899143.08601920287698
getTask <- sort(getTask)
# freeServ
# вектор событий (времен с начала моделирования),
# когда сервер заканчивает обработку i-й присланной программы
# qSize
# вектор размеров очереди, когда приходит i-ая присланная программа. Первый всегда 0
# waiTime
# вектор времен ожидания завершения i-й присланной программы с учетом
# ожидания в очереди
freeServ <- vector(mode='double', length=length(getTask))
qSize <- vector(mode='integer', length=length(getTask))
waiTime <- vector(mode='double', length=length(getTask))
qDec <- vector(mode='double', length=length(getTask))
# время от начала моделирования, когда сервер освободится,
# и будет готов обработать программу
freeT <- 0
for (i in 1:length(getTask)) {
# время получения задачи
recTime <- getTask[i]
# необходимое время для прогона программы
requTime <- rexp(1, lambda2)
if (freeT < recTime) {
# будет выполняться сейчас
freeT <- recTime + requTime
waiTime[i] <- requTime # время выполнения
} else {
# будет выполняться после завершения предыдущей
freeT <- freeT + requTime
waiTime[i] <- freeT - recTime # время ожидания в очереди + время выполнения
qDec <- append(qDec, freeT)
}
qDec <- qDec[qDec > recTime]
qSize[i] <- length(qDec)
freeServ[i] <- freeT
}
return(list(
getTask = getTask,
freeServ = freeServ,
qSize = qSize,
waiTime = waiTime
))
}
res<-F1(k, 80, t2, 10000)
# вероятность того, что программа не будет выполнена сразу же, как только она
# поступила на терминал
length(
F1$event_queue_size[F1$event_queue_size > 0]
) / length(F1$event_queue_size)
Variant<-1
set.seed(Variant)
k<-sample(c(10:25),1)
t1<-sample(c(14:20),1)
t2<-sample(c(2:5),1)
View(data.frame(k,t1,t2))
F1 <- function(lk, lt1, lt2, N) {
lambda1 = 1/lt1
lambda2 = 1/lt2
set.seed(Variant)
# вектор событий (времен с начала моделирования) загрузки программ на сервер
getTask <- vector(mode='double', length=N*lk)
getTask[1:lk] <- rexp(lk, lambda1)
for (i in 1:(N-1)) {
getTask[(i*lk+1):(i*lk+lk)] <- getTask[((i-1)*lk+1):(i*lk)] + rexp(lk, lambda1)
}
# print(getTask) => sorted vector(mode='double', length=N*k)
# e.g. 0.5368717806413770.9901529230642491.240166490021951.605907236501722.915671849899143.08601920287698
getTask <- sort(getTask)
# freeServ
# вектор событий (времен с начала моделирования),
# когда сервер заканчивает обработку i-й присланной программы
# qSize
# вектор размеров очереди, когда приходит i-ая присланная программа. Первый всегда 0
# waiTime
# вектор времен ожидания завершения i-й присланной программы с учетом
# ожидания в очереди
freeServ <- vector(mode='double', length=length(getTask))
qSize <- vector(mode='integer', length=length(getTask))
waiTime <- vector(mode='double', length=length(getTask))
qDec <- vector(mode='double', length=length(getTask))
# время от начала моделирования, когда сервер освободится,
# и будет готов обработать программу
freeT <- 0
for (i in 1:length(getTask)) {
# время получения задачи
recTime <- getTask[i]
# необходимое время для прогона программы
requTime <- rexp(1, lambda2)
if (freeT < recTime) {
# будет выполняться сейчас
freeT <- recTime + requTime
waiTime[i] <- requTime # время выполнения
} else {
# будет выполняться после завершения предыдущей
freeT <- freeT + requTime
waiTime[i] <- freeT - recTime # время ожидания в очереди + время выполнения
qDec <- append(qDec, freeT)
}
qDec <- qDec[qDec > recTime]
qSize[i] <- length(qDec)
freeServ[i] <- freeT
}
return(list(
getTask = getTask,
freeServ = freeServ,
qSize = qSize,
waiTime = waiTime
))
}
res<-F1(k, 80, t2, 10000)
# вероятность того, что программа не будет выполнена сразу же, как только она
# поступила на терминал
length(
F1$qSize[F1$qSize > 0]
) / length(F1$qSize)
Variant<-1
set.seed(Variant)
k<-sample(c(10:25),1)
t1<-sample(c(14:20),1)
t2<-sample(c(2:5),1)
View(data.frame(k,t1,t2))
exp2 <- function(k_local, t1_local, t2_local, N) {
lambda1 = 1/t1_local
lambda2 = 1/t2_local
set.seed(Variant)
# вектор событий (времен с начала моделирования) загрузки программ на сервер
event_task_recieve <- vector(mode='double', length=N*k_local)
event_task_recieve[1:k_local] <- rexp(k_local, lambda1)
for (i in 1:(N-1)) {
event_task_recieve[(i*k_local+1):(i*k_local+k_local)] <- event_task_recieve[((i-1)*k_local+1):(i*k_local)] + rexp(k_local, lambda1)
}
# print(event_task_recieve) => sorted vector(mode='double', length=N*k)
# e.g. 0.5368717806413770.9901529230642491.240166490021951.605907236501722.915671849899143.08601920287698
event_task_recieve <- sort(event_task_recieve)
# event_server_free
# вектор событий (времен с начала моделирования),
# когда сервер заканчивает обработку i-й присланной программы
# event_queue_size
# вектор размеров очереди, когда приходит i-ая присланная программа. Первый всегда 0
# event_wait_time
# вектор времен ожидания завершения i-й присланной программы с учетом
# ожидания в очереди
event_server_free <- vector(mode='double', length=length(event_task_recieve))
event_queue_size <- vector(mode='integer', length=length(event_task_recieve))
event_wait_time <- vector(mode='double', length=length(event_task_recieve))
event_queue_decrease_times <- vector(mode='double', length=length(event_task_recieve))
# время от начала моделирования, когда сервер освободится,
# и будет готов обработать программу
time_free <- 0
for (i in 1:length(event_task_recieve)) {
# время получения задачи
time_recieved <- event_task_recieve[i]
# необходимое время для прогона программы
time_required <- rexp(1, lambda2)
if (time_free < time_recieved) {
# будет выполняться сейчас
time_free <- time_recieved + time_required
event_wait_time[i] <- time_required # время выполнения
} else {
# будет выполняться после завершения предыдущей
time_free <- time_free + time_required
event_wait_time[i] <- time_free - time_recieved # время ожидания в очереди + время выполнения
event_queue_decrease_times <- append(event_queue_decrease_times, time_free)
}
event_queue_decrease_times <- event_queue_decrease_times[event_queue_decrease_times > time_recieved]
event_queue_size[i] <- length(event_queue_decrease_times)
event_server_free[i] <- time_free
}
return(list(
event_task_recieve = event_task_recieve,
event_server_free = event_server_free,
event_queue_size = event_queue_size,
event_wait_time = event_wait_time
))
}
exp2_res_2 = exp2(k, 80, t2, 10000)
# вероятность того, что программа не будет выполнена сразу же, как только она
# поступила на терминал
length(
exp2_res_2$event_queue_size[exp2_res_2$event_queue_size > 0]
) / length(exp2_res_2$event_queue_size)
# # среднее время до получения пользователем результатов реализации
mean(exp2_res_2$event_wait_time)
# # среднее количество программ, ожидающих выполнения на сервере.
mean(exp2_res_2$event_queue_size)
Variant<-1
set.seed(Variant)
k<-sample(c(10:25),1)
t1<-sample(c(14:20),1)
t2<-sample(c(2:5),1)
View(data.frame(k,t1,t2))
F1 <- function(lk, lt1, lt2, N) {
lambda1 = 1/lt1
lambda2 = 1/lt2
set.seed(Variant)
# вектор событий (времен с начала моделирования) загрузки программ на сервер
getTask <- vector(mode='double', length=N*lk)
getTask[1:lk] <- rexp(lk, lambda1)
for (i in 1:(N-1)) {
getTask[(i*lk+1):(i*lk+lk)] <- getTask[((i-1)*lk+1):(i*lk)] + rexp(lk, lambda1)
}
# print(getTask) => sorted vector(mode='double', length=N*k)
# e.g. 0.5368717806413770.9901529230642491.240166490021951.605907236501722.915671849899143.08601920287698
getTask <- sort(getTask)
# freeServ
# вектор событий (времен с начала моделирования),
# когда сервер заканчивает обработку i-й присланной программы
# qSize
# вектор размеров очереди, когда приходит i-ая присланная программа. Первый всегда 0
# waiTime
# вектор времен ожидания завершения i-й присланной программы с учетом
# ожидания в очереди
freeServ <- vector(mode='double', length=length(getTask))
qSize <- vector(mode='integer', length=length(getTask))
waiTime <- vector(mode='double', length=length(getTask))
decrQ <- vector(mode='double', length=length(getTask))
# время от начала моделирования, когда сервер освободится,
# и будет готов обработать программу
time_free <- 0
for (i in 1:length(getTask)) {
# время получения задачи
recTime <- getTask[i]
# необходимое время для прогона программы
requTime <- rexp(1, lambda2)
if (time_free < recTime) {
# будет выполняться сейчас
time_free <- recTime + requTime
waiTime[i] <- requTime # время выполнения
} else {
# будет выполняться после завершения предыдущей
time_free <- time_free + requTime
waiTime[i] <- time_free - recTime # время ожидания в очереди + время выполнения
decrQ <- append(decrQ, time_free)
}
decrQ <- decrQ[decrQ > recTime]
qSize[i] <- length(decrQ)
freeServ[i] <- time_free
}
return(list(
getTask = getTask,
freeServ = freeServ,
qSize = qSize,
waiTime = waiTime
))
}
F1_res_2 = F1(k, 80, t2, 10000)
# вероятность того, что программа не будет выполнена сразу же, как только она
# поступила на терминал
length(
F1_res_2$qSize[F1_res_2$qSize > 0]
) / length(F1_res_2$qSize)
# # среднее время до получения пользователем результатов реализации
mean(F1_res_2$waiTime)
# # среднее количество программ, ожидающих выполнения на сервере.
mean(F1_res_2$qSize)
Variant<-1
set.seed(Variant)
k<-sample(c(10:25),1)
t1<-sample(c(14:20),1)
t2<-sample(c(2:5),1)
View(data.frame(k,t1,t2))
F1 <- function(lk, lt1, lt2, N) {
lambda1 = 1/lt1
lambda2 = 1/lt2
set.seed(Variant)
getTask <- vector(mode='double', length=N*lk)
getTask[1:lk] <- rexp(lk, lambda1)
for (i in 1:(N-1)) {
getTask[(i*lk+1):(i*lk+lk)] <- getTask[((i-1)*lk+1):(i*lk)] + rexp(lk, lambda1)
}
getTask <- sort(getTask)
freeServ <- vector(mode='double', length=length(getTask))
qSize <- vector(mode='integer', length=length(getTask))
waiTime <- vector(mode='double', length=length(getTask))
decrQ <- vector(mode='double', length=length(getTask))
time_free <- 0
for (i in 1:length(getTask)) {
recTime <- getTask[i]
requTime <- rexp(1, lambda2)
if (time_free < recTime) {
time_free <- recTime + requTime
waiTime[i] <- requTime
} else {
time_free <- time_free + requTime
waiTime[i] <- time_free - recTime
decrQ <- append(decrQ, time_free)
}
decrQ <- decrQ[decrQ > recTime]
qSize[i] <- length(decrQ)
freeServ[i] <- time_free
}
return(list(
getTask = getTask,
freeServ = freeServ,
qSize = qSize,
waiTime = waiTime
))
}
F1_res_2 = F1(k, 80, t2, 10000)
# вероятность того, что программа не будет выполнена сразу же
length(
F1_res_2$qSize[F1_res_2$qSize > 0]
) / length(F1_res_2$qSize)
# среднее время до получения результатов
mean(F1_res_2$waiTime)
# среднее количество ожидающих программ
mean(F1_res_2$qSize)
Variant<-1
set.seed(Variant)
k<-sample(c(10:25),1)
t1<-sample(c(14:20),1)
t2<-sample(c(2:5),1)
View(data.frame(k,t1,t2))
Variant<-1
set.seed(Variant)
k<-sample(c(10:25),1)
t1<-sample(c(14:20),1)
t2<-sample(c(2:5),1)
View(data.frame(k,t1,t2))
F1 <- function(lk, lt1, lt2, N) {
lambda1 = 1/lt1
lambda2 = 1/lt2
set.seed(Variant)
getTask <- vector(mode='double', length=N*lk)
getTask[1:lk] <- rexp(lk, lambda1)
for (i in 1:(N-1)) {
getTask[(i*lk+1):(i*lk+lk)] <- getTask[((i-1)*lk+1):(i*lk)] + rexp(lk, lambda1)
}
getTask <- sort(getTask)
freeServ <- vector(mode='double', length=length(getTask))
qSize <- vector(mode='integer', length=length(getTask))
waiTime <- vector(mode='double', length=length(getTask))
decrQ <- vector(mode='double', length=length(getTask))
time_free <- 0
for (i in 1:length(getTask)) {
recTime <- getTask[i]
requTime <- rexp(1, lambda2)
if (time_free < recTime) {
time_free <- recTime + requTime
waiTime[i] <- requTime
} else {
time_free <- time_free + requTime
waiTime[i] <- time_free - recTime
decrQ <- append(decrQ, time_free)
}
decrQ <- decrQ[decrQ > recTime]
qSize[i] <- length(decrQ)
freeServ[i] <- time_free
}
return(list(
getTask = getTask,
freeServ = freeServ,
qSize = qSize,
waiTime = waiTime
))
}
F1_res_2 = F1(k, 80, t2, 10000)
# вероятность того, что программа не будет выполнена сразу же
length(
F1_res_2$qSize[F1_res_2$qSize > 0]
) / length(F1_res_2$qSize)
# среднее время до получения результатов
mean(F1_res_2$waiTime)
# среднее количество ожидающих программ
mean(F1_res_2$qSize)
